//! Vehicles related types

use crate::chunk_reader::ChunkReader;
use crate::error::Error;

/// Vehicles informations
#[derive(Debug, PartialEq)]
pub struct Vehicles {
    pub trains: Vec<Train>,
}

impl Vehicles {

    /// Parse the vehicles information
    pub fn parse(buffer: &Vec<u8>) -> Result<Vehicles, Error> {

        let mut chunk = ChunkReader::find(buffer, "VEHS")?; // 56 45 48 53

        // Fields from https://github.com/OpenTTD/OpenTTD/blob/8537fa72063a7376065fd996fa249cc7dbfdb2f3/src/saveload/vehicle_sl.cpp#L590

        let mut trains = vec![];

        loop {
            let tp = chunk.fetch::<u8>()?; // vehicle type

            println!("tp {}", tp);

            match tp {
                0 => { // Train
                    trains.push(Train::parse(&mut chunk)?);
                },
                _ => {}
            };

            match chunk.advance_slice()? {
                Some(c) => chunk = c,
                None => break
            }
        }

        println!("trains {}", trains.len());

        Ok(Vehicles {
            trains
        })
    }
}

/// Train informations
#[derive(Debug, PartialEq)]
pub struct Train {
}

impl Train {

    /// Parse the train information
    pub fn parse(chunk: &mut ChunkReader) -> Result<Train, Error> {

        let sub = chunk.fetch::<u8>()?; // subtype
        let next = chunk.fetch::<u8>()?; // next vehicle

        println!("{} {}", sub, next);

        todo!("??");

        Ok(Self {
        })
    }
}


#[cfg(test)]
mod test {

    use crate::vehicle::*;

    #[test]
    fn base() -> Result<(), String> {

        let vehicles = Vehicles::parse(&VEHS.to_vec())
            .map_err(|e| e.to_string())?;

        assert_eq!(1, vehicles.trains.len());

        let vehicle = &vehicles.trains[0];


        Ok(())
    }

    static VEHS: [u8; 187] = [0x56, 0x45, 0x48, 0x53, 0x02, 0x4d, 0x1c, 0x00, 0x04, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xdc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x37, 0x79, 0x00, 0x00, 0x00, 0x08, 0x03, 0x05, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x44, 0x00, 0x0a, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x2e, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x2e, 0x00, 0x00, 0x1c, 0x98, 0x00, 0x0b, 0x22, 0x8b, 0x00, 0x96, 0xff, 0x8b, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xd2, 0xc9, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

}
